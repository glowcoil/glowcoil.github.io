use basedrop::{Collector, Handle, Owned};
use core::mem::drop;

let mut collector = Collector::new();
let handle = collector.handle();
let x = Owned::new(&handle, 3);

let result = collector.try_cleanup();
assert!(result.is_err());
let mut collector = result.unwrap_err();

drop(handle);
drop(x);
collector.collect();

assert!(collector.try_cleanup().is_ok());


<p>In real-time audio, deadlines are critical. Your code has on the order of several milliseconds to fill a buffer with samples to be shipped off to the <a href="https://en.wikipedia.org/wiki/Digital-to-analog_converter">DAC</a>, milliseconds which it may be sharing with a number of other audio plugins. If your code takes too long to produce those samples, there are no second chances; they simply won't get played, and the user will hear an objectionable glitch or stutter instead.</p>

<p>As a consequence, real-time audio code is subject to </p>

<a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">time waits for nothing</a>
